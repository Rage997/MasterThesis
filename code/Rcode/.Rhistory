rep(0, 10)
negBin=F
alpha = 3
# n.iter = 10
p = 10
p.y = p*(p-1)/2
n = 100
d = 2
d.true = d
dd=1
n.clust = 3
time = 1:n
sender.true = rep(0, p)
receiver.true = rep(0, p)
spline.time.true = rep(alpha, n)
logis=function(time, a, b, c) a*(exp(10*(time/n-b))/(1 + exp(10*(time/n-b)))-.5) + c
# time=seq(0, 10, length.out = n)
a = runif(p*d.true, -1, 1)*1
b = rep(runif(p, 0.2, 0.8), d.true)
c.clust=0
if(n.clust>1){
print("clustering implemented for dimension 2 only")
c.clust = 5*matrix(c(0,0,1,1,-1,1,-1,-1,1,-1), ncol=2, byrow=T)[rep(1:n.clust, each=floor(p/n.clust) , length.out=p), ]
c.clust = as.vector(t(c.clust))
}
c = runif(p*d.true,-dd,dd) + c.clust
runif
?runif
c
c.clust
c
c.clust=0
if(n.clust>1){
print("clustering implemented for dimension 2 only")
c.clust = 1*matrix(c(0,0,1,1,-1,1,-1,-1,1,-1), ncol=2, byrow=T)[rep(1:n.clust, each=floor(p/n.clust) , length.out=p), ]
c.clust = as.vector(t(c.clust))
}
c = runif(p*d.true,-dd,dd) + c.clust
c.clust
# cc.true = cc = 3
X=matrix(NA, n, p*d.true)
for(i in 1:(p*d.true))X[, i] = logis(time, a[i], b[i], c[i])
X
a
b
c
# for(i in 1:n)plot(matrix(X[i,], ncol=2, byrow=T ), main=i)
# Plot trajectories
matplot(X, ty="l")
X
size(X)
dim(X)
n
c.clust=0
if(n.clust>1){
print("clustering implemented for dimension 2 only")
c.clust = 50*matrix(c(0,0,1,1,-1,1,-1,-1,1,-1), ncol=2, byrow=T)[rep(1:n.clust, each=floor(p/n.clust) , length.out=p), ]
c.clust = as.vector(t(c.clust))
}
c = runif(p*d.true,-dd,dd) + c.clust
# cc.true = cc = 3
X=matrix(NA, n, p*d.true)
for(i in 1:(p*d.true))X[, i] = logis(time, a[i], b[i], c[i])
# for(i in 1:n)plot(matrix(X[i,], ncol=2, byrow=T ), main=i)
# Plot trajectories
matplot(X, ty="l")
c.clust = 5*matrix(c(0,0,1,1,-1,1,-1,-1,1,-1), ncol=2, byrow=T)[rep(1:n.clust, each=floor(p/n.clust) , length.out=p), ]
c.clust = as.vector(t(c.clust))
if(n.clust>1){
print("clustering implemented for dimension 2 only")
c.clust = 5*matrix(c(0,0,1,1,-1,1,-1,-1,1,-1), ncol=2, byrow=T)[rep(1:n.clust, each=floor(p/n.clust) , length.out=p), ]
c.clust = as.vector(t(c.clust))
}
c = runif(p*d.true,-dd,dd) + c.clust
# cc.true = cc = 3
X=matrix(NA, n, p*d.true)
for(i in 1:(p*d.true))X[, i] = logis(time, a[i], b[i], c[i])
# for(i in 1:n)plot(matrix(X[i,], ncol=2, byrow=T ), main=i)
# Plot trajectories
matplot(X, ty="l")
b
lambda.true = array(NA, dim = c(p, p, n))
Y.array = array(NA, dim = c(p, p, n))
for(t in 1:n)for(i in 1:p)for(j in 1:p){
if( i!=j ){
lambda.true[i,j,t] = exp(  spline.time.true[t] + sender.true[i] + receiver.true[j] - as.numeric(dist(matrix(X[ t, c((i-1)*d.true + 1:d.true, (j-1)*d.true + 1:d.true) ], ncol = d.true, byrow=T))^2) )
Y.array[ i, j, t] = if(negBin==T){rnbinom( 1, 1, mu=lambda.true[ i, j, t])}else{rpois( 1, lambda.true[ i, j, t])}
}
}
plot(time, lambda.true[ 1, 2, ], ylim=c(0, max(Y.array, na.rm = T)), ty="l")
lambda.true
dim(lambda.true)
plot(time, lambda.true[ 1, 5, ], ylim=c(0, max(Y.array, na.rm = T)), ty="l")
plot(time, lambda.true[ 1, , ], ylim=c(0, max(Y.array, na.rm = T)), ty="l")
plot(time, lambda.true[ , , ], ylim=c(0, max(Y.array, na.rm = T)), ty="l")
plot(time, lambda.true[ 1, 2, ], ylim=c(0, max(Y.array, na.rm = T)), ty="l")
plot(time, lambda.true[ 1, 2, ], ylim=c(0, max(Y.array, na.rm = T)), ty="l")
# plot( time, Y.array[ 1, 2, ] )
for(i in 1:p)for(j in 1:p){
if( i!=j ){
lines(time, lambda.true[ i, j, ], col=i+j)
# points( time, Y.array[ i, j, ], ylim=c(0, max(Y, na.rm = T)) )
}
}
lambda
X
lambda.true
dim(lambda.true)
dim(X)
source("~/Documents/MasterThesis/code/Rcode/load_data.R")
d <- 31
source("~/Documents/MasterThesis/code/Rcode/load_data.R")
source("~/Documents/MasterThesis/code/Rcode/EKF.R")
n.iter < 1
source("~/Documents/MasterThesis/code/Rcode/EKF.R")
source("~/Documents/MasterThesis/code/Rcode/load_data.R")
source("~/Documents/MasterThesis/code/Rcode/load_data.R")
n <- dim(X)[2]
# p, d hardcoded in python
p <- 18
d <- 31
d.true <- d
n.iter < 1
n.iter <- 1
source("~/Documents/MasterThesis/code/Rcode/EKF.R")
source("~/Documents/MasterThesis/code/Rcode/SimLatentSpace.R")
source("~/Documents/MasterThesis/code/Rcode/SimLatentSpace.R")
source("~/Documents/MasterThesis/code/Rcode/SimLatentSpace.R")
spline
spline.time.true
Y.kf
dim(Y.kf)
source("~/Documents/MasterThesis/code/Rcode/EKF.R")
n.iter = 1
source("~/Documents/MasterThesis/code/Rcode/EKF.R")
source("~/Documents/MasterThesis/code/Rcode/SimLatentSpace.R")
source("~/Documents/MasterThesis/code/Rcode/EKF.R")
source("~/Documents/MasterThesis/code/Rcode/EKF.R")
source("~/Documents/MasterThesis/code/Rcode/load_data.R")
source("~/Documents/MasterThesis/code/Rcode/load_data.R")
source("~/Documents/MasterThesis/code/Rcode/load_data.R")
source("~/Documents/MasterThesis/code/Rcode/load_data.R")
Y.kf
source("~/Documents/MasterThesis/code/Rcode/load_data.R")
# See doc: https://cran.r-project.org/web/packages/reticulate/index.html
library(reticulate)
np <- import("numpy")
# import data
mat <- np$load("../data/matrix.npy") # for matrix in R^{T, S, R}
# mat <- np$load("../matrix_full.npy") # for full matrix in R^{T, S+R, S+R}
Y.kf <- mat
n <- dim(Y_kf)[1] # timesteps
# import data
mat <- np$load("../data/matrix.npy") # for matrix in R^{T, S, R}
# mat <- np$load("../matrix_full.npy") # for full matrix in R^{T, S+R, S+R}
Y.kf <- mat
n <- dim(Y_kf)[1] # timesteps
n <- dim(Y.kf)[1] # timesteps
# s, r hardcoded in python
s <- 18
r <- 31
# My matrix size is p*p and not p*(p-1)/2 though. What am I doing wrong?
p <- s+r
#p.y = p*(p-1)/2
p.y <- p*p
d <- 2
d.true <- d
n.iter <- 1
sender.true = rep(0, s)
receiver.true = rep(0, r)
alpha <- 3
spline.time.true = rep(alpha, n)
# See in hazard function gam.sum.pred.vec
gam.sum.pred.mat = matrix( 2*exp(alpha), n, p*(p-1)/2)  # its twice the rate!!!!!!!
X <- NaN
source("~/Documents/MasterThesis/code/Rcode/load_data.R")
source("~/Documents/MasterThesis/code/Rcode/EKF.R")
X
dim(X)
# Inizialiation T=0
X.prior = X.post = matrix(NA, n, p*d) # points in latent space (Expected value of X)
p
p*d
p
dim(Y.kf)
p*p
p
s
r
p
p*2
p*p
31*18
#p.y = p*(p-1)/2
p.y <- s*r
source("~/Documents/MasterThesis/code/Rcode/load_data.R")
source("~/Documents/MasterThesis/code/Rcode/EKF.R")
X
X_prior
require(Matrix)
require(mgcv)
# hazard function / rate -> poisson variable
h.function=function(x.vec, gam.sum.pred.vec) gam.sum.pred.vec * exp( -as.vector(dist(matrix(x.vec, ncol=d, byrow=T))^2))
d.h.function = function(x.i, x.j, gam.sum.pred.ij){
# First derivative (taylor's expansion) -> latent space
dist.tmp = dist(rbind(x.i, x.j))^2
2 * gam.sum.pred.ij * exp(- dist.tmp) * c(x.j - x.i, x.i - x.j)
}
# Inizialiation T=0
X.prior = X.post = matrix(NA, n, p*d) # points in latent space (Expected value of X)
P.prior = P.post = array(NA, dim=c(p*d,p*d,n)) # variance of X
#tuning parameters (transition noise)
Q = diag(0.001, p*d) # X_t+1  = X_T + eps_t : sigma is var(eps)
# Inizialization: starting points    TRY WITH DIFFERENT X STARTING POINTS!
P_0.smooth = P_0 = Q
#x_0.smooth = x_0 = runif(p*d, -1, 1)
# TODO generate it from a gaussian or whatever
x_0.smooth = x_0 = rnorm(p*d, 0, 1)
# Populate H_ij = [derivative function(i,j)] -> sparse matrix
build.H = function(x.prior, gam.sum.pred.vec){
H = matrix(0, p.y, p*d)
ii = 1
for(i in 1:(p-1))for(j in (i+1):p){
H[ii, c(d*i - (d-1):0, d*j - (d-1):0)] = d.h.function(x.prior[c(d*i - (d-1):0)], x.prior[c(d*j - (d-1):0)] , gam.sum.pred.vec[ii] )
ii = ii + 1
}
return(H)
}
# Populate H_ij = [derivative function(i,j)] -> sparse matrix
build.H = function(x.prior, gam.sum.pred.vec){
H = matrix(0, p.y, p*d)
ii = 1
for(i in 1:(p-1))for(j in (i+1):p){
H[ii, c(d*i - (d-1):0, d*j - (d-1):0)] = d.h.function(x.prior[c(d*i - (d-1):0)], x.prior[c(d*j - (d-1):0)] , gam.sum.pred.vec[ii] )
ii = ii + 1
}
return(H)
}
Q
dim(x_0.smooth)
p*d
rnorm(p*d, 0, 1)
# Inizialization: starting points    TRY WITH DIFFERENT X STARTING POINTS!
P_0.smooth = P_0 = Q
#x_0.smooth = x_0 = runif(p*d, -1, 1)
# TODO generate it from a gaussian or whatever
x_0.smooth = x_0 = rnorm(p*d, 0, 1)
# Populate H_ij = [derivative function(i,j)] -> sparse matrix
build.H = function(x.prior, gam.sum.pred.vec){
H = matrix(0, p.y, p*d)
ii = 1
for(i in 1:(p-1))for(j in (i+1):p){
H[ii, c(d*i - (d-1):0, d*j - (d-1):0)] = d.h.function(x.prior[c(d*i - (d-1):0)], x.prior[c(d*j - (d-1):0)] , gam.sum.pred.vec[ii] )
ii = ii + 1
}
return(H)
}
dim(x_0.smooth)
x_0.smooth
length(x_0.smooth)
# Populate H_ij = [derivative function(i,j)] -> sparse matrix
build.H = function(x.prior, gam.sum.pred.vec){
H = matrix(0, p.y, p*d)
ii = 1
for(i in 1:(p-1))for(j in (i+1):p){
H[ii, c(d*i - (d-1):0, d*j - (d-1):0)] = d.h.function(x.prior[c(d*i - (d-1):0)], x.prior[c(d*j - (d-1):0)] , gam.sum.pred.vec[ii] )
ii = ii + 1
}
return(H)
}
repeat.filter=1
hist.list = NULL
gam.save = NULL
if(t==1){ # init (page 9 igor paper)
X.prior[ t, ] = x_0
P.prior[ , , t] = P_0 + Q
}else{ # a-prior distribution
X.prior[ t, ] = X.post[ t-1, ]
P.prior[ , , t] = P.post[ , , t-1] + Q
}
x_0
X.prior
X.prior[0,]
# See page 9
H = build.H(X.prior[ t, ], gam.sum.pred.mat[ t, ]) #first derivative (gam.sum is an offset) on X_prior
t=1
X.prior[ t, ]
gam.sum.pred.mat[ t, ]
s
r
dim(H)
p
H[ii, c(d*i - (d-1):0, d*j - (d-1):0)] = d.h.function(x.prior[c(d*i - (d-1):0)], x.prior[c(d*j - (d-1):0)] , gam.sum.pred.vec[ii] )
x.prior <- X.prior[ t, ]
gam.sum.pred.vec <- gam.sum.pred.mat[ t, ]
H = matrix(0, p.y, p*d)
ii = 1
H[ii, c(d*i - (d-1):0, d*j - (d-1):0)] = d.h.function(x.prior[c(d*i - (d-1):0)], x.prior[c(d*j - (d-1):0)] , gam.sum.pred.vec[ii] )
H[ii, c(d*i - (d-1):0, d*j - (d-1):0)]
ii
c(d*i - (d-1):0, d*j - (d-1):0)
j
i
dim(H)
p
?as.vector
# hazard function / rate -> poisson variable
h.function=function(x.vec, gam.sum.pred.vec) gam.sum.pred.vec * exp( -as.vector(dist(matrix(x.vec, ncol=d, byrow=T))^2))
source("~/Documents/MasterThesis/code/Rcode/SimLatentSpace.R")
source("~/Documents/MasterThesis/code/Rcode/EKF.R")
debugSource("~/Documents/MasterThesis/code/Rcode/EKF.R")
X.prior[ t, ]
[ t, ]
gam.sum.pred.mat[ t, ]
dim(gam.sum.pred.mat[ t, ])
length(gam.sum.pred.mat[ t, ])
length(X_prior[t,])
length(X.prior[t,])
vv = mu
debugSource("~/Documents/MasterThesis/code/Rcode/EKF.R")
x.vec
# hazard function / rate -> poisson variable
h.function=function(x.vec, gam.sum.pred.vec) gam.sum.pred.vec * exp( -as.vector(dist(matrix(x.vec, ncol=d, byrow=T))^2))
# hazard function / rate -> poisson variable
h.function=function(x.vec, gam.sum.pred.vec) gam.sum.pred.vec * exp( -as.vector(dist(matrix(x.vec, ncol=d, byrow=T))^2))
x.vec
debugSource("~/Documents/MasterThesis/code/Rcode/EKF.R")
gam.sum.pred.vec * exp( -as.vector(dist(matrix(x.vec, ncol=d, byrow=T))^2))
x.vec
gam.sum.pred.vec * exp( -as.vector(dist(matrix(x.vec, ncol=d, byrow=T))^2))
gam.sum.pred.vec * exp( -as.vector(dist(matrix(x.vec, ncol=d, byrow=T))^2))
gam.sum.pred.vec * exp( -as.vector(dist(matrix(x.vec, ncol=d, byrow=T))^2))
debugSource("~/Documents/MasterThesis/code/Rcode/EKF.R")
gam.sum.pred.vec * exp( -as.vector(dist(matrix(x.vec, ncol=d, byrow=T))^2))
debugSource("~/Documents/MasterThesis/code/Rcode/EKF.R")
x.vec <0 X.prior[ t, ]
x.vec <- X.prior[ t, ]
matrix(x.vec, ncol=d, byrow=T)
X.vec
x.vec
length(X.vec)
dist(matrix(x.vec, ncol=d, byrow=T)
)
dist(matrix(x.vec, ncol=d, byrow=T)
)
dist(matrix(x.vec, ncol=d, byrow=T)
)
dist(matrix(x.vec, ncol=d, byrow=T))
as.vector(dist(matrix(x.vec, ncol=d, byrow=T)))
D <- dist(matrix(x.vec, ncol=d, byrow=T))
dim(D)
lenght(D)
length(D)
as.vector(dist(matrix(x.vec, ncol=d, byrow=T)))
exp(as.vector(dist(matrix(x.vec, ncol=d, byrow=T))))
debugSource("~/Documents/MasterThesis/code/Rcode/EKF.R")
x.i
x.j
rbind(x.i, x.j)
(rbind(x.i, x.j))
dist(rbind(x.i, x.j))
c(x.j - x.i, x.i - x.j)
x.j
x.j - x.i
gam.sum.pred.ij
exp(- dist.tmp)
# First derivative (taylor's expansion) -> latent space
dist.tmp = dist(rbind(x.i, x.j))^2
exp(- dist.tmp)
dist.tmp
debugSource("~/Documents/MasterThesis/code/Rcode/EKF.R")
dist.tmp
# First derivative (taylor's expansion) -> latent space
dist.tmp = dist(rbind(x.i, x.j))^2
dist.tmp
exp(- dist.tmp)
c(x.j - x.i, x.i - x.j)
x.i
x.j
dist.tmp
rnorm(p*d, 0, 1)
rnorm
?rnorm
atrix(0, p.y, p*d)
matrix(0, p.y, p*d)
