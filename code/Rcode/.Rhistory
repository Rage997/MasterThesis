rep(0, 10)
negBin=F
alpha = 3
# n.iter = 10
p = 10
p.y = p*(p-1)/2
n = 100
d = 2
d.true = d
dd=1
n.clust = 3
time = 1:n
sender.true = rep(0, p)
receiver.true = rep(0, p)
spline.time.true = rep(alpha, n)
logis=function(time, a, b, c) a*(exp(10*(time/n-b))/(1 + exp(10*(time/n-b)))-.5) + c
# time=seq(0, 10, length.out = n)
a = runif(p*d.true, -1, 1)*1
b = rep(runif(p, 0.2, 0.8), d.true)
c.clust=0
if(n.clust>1){
print("clustering implemented for dimension 2 only")
c.clust = 5*matrix(c(0,0,1,1,-1,1,-1,-1,1,-1), ncol=2, byrow=T)[rep(1:n.clust, each=floor(p/n.clust) , length.out=p), ]
c.clust = as.vector(t(c.clust))
}
c = runif(p*d.true,-dd,dd) + c.clust
runif
?runif
c
c.clust
c
c.clust=0
if(n.clust>1){
print("clustering implemented for dimension 2 only")
c.clust = 1*matrix(c(0,0,1,1,-1,1,-1,-1,1,-1), ncol=2, byrow=T)[rep(1:n.clust, each=floor(p/n.clust) , length.out=p), ]
c.clust = as.vector(t(c.clust))
}
c = runif(p*d.true,-dd,dd) + c.clust
c.clust
# cc.true = cc = 3
X=matrix(NA, n, p*d.true)
for(i in 1:(p*d.true))X[, i] = logis(time, a[i], b[i], c[i])
X
a
b
c
# for(i in 1:n)plot(matrix(X[i,], ncol=2, byrow=T ), main=i)
# Plot trajectories
matplot(X, ty="l")
X
size(X)
dim(X)
n
c.clust=0
if(n.clust>1){
print("clustering implemented for dimension 2 only")
c.clust = 50*matrix(c(0,0,1,1,-1,1,-1,-1,1,-1), ncol=2, byrow=T)[rep(1:n.clust, each=floor(p/n.clust) , length.out=p), ]
c.clust = as.vector(t(c.clust))
}
c = runif(p*d.true,-dd,dd) + c.clust
# cc.true = cc = 3
X=matrix(NA, n, p*d.true)
for(i in 1:(p*d.true))X[, i] = logis(time, a[i], b[i], c[i])
# for(i in 1:n)plot(matrix(X[i,], ncol=2, byrow=T ), main=i)
# Plot trajectories
matplot(X, ty="l")
c.clust = 5*matrix(c(0,0,1,1,-1,1,-1,-1,1,-1), ncol=2, byrow=T)[rep(1:n.clust, each=floor(p/n.clust) , length.out=p), ]
c.clust = as.vector(t(c.clust))
if(n.clust>1){
print("clustering implemented for dimension 2 only")
c.clust = 5*matrix(c(0,0,1,1,-1,1,-1,-1,1,-1), ncol=2, byrow=T)[rep(1:n.clust, each=floor(p/n.clust) , length.out=p), ]
c.clust = as.vector(t(c.clust))
}
c = runif(p*d.true,-dd,dd) + c.clust
# cc.true = cc = 3
X=matrix(NA, n, p*d.true)
for(i in 1:(p*d.true))X[, i] = logis(time, a[i], b[i], c[i])
# for(i in 1:n)plot(matrix(X[i,], ncol=2, byrow=T ), main=i)
# Plot trajectories
matplot(X, ty="l")
b
lambda.true = array(NA, dim = c(p, p, n))
Y.array = array(NA, dim = c(p, p, n))
for(t in 1:n)for(i in 1:p)for(j in 1:p){
if( i!=j ){
lambda.true[i,j,t] = exp(  spline.time.true[t] + sender.true[i] + receiver.true[j] - as.numeric(dist(matrix(X[ t, c((i-1)*d.true + 1:d.true, (j-1)*d.true + 1:d.true) ], ncol = d.true, byrow=T))^2) )
Y.array[ i, j, t] = if(negBin==T){rnbinom( 1, 1, mu=lambda.true[ i, j, t])}else{rpois( 1, lambda.true[ i, j, t])}
}
}
plot(time, lambda.true[ 1, 2, ], ylim=c(0, max(Y.array, na.rm = T)), ty="l")
lambda.true
dim(lambda.true)
plot(time, lambda.true[ 1, 5, ], ylim=c(0, max(Y.array, na.rm = T)), ty="l")
plot(time, lambda.true[ 1, , ], ylim=c(0, max(Y.array, na.rm = T)), ty="l")
plot(time, lambda.true[ , , ], ylim=c(0, max(Y.array, na.rm = T)), ty="l")
plot(time, lambda.true[ 1, 2, ], ylim=c(0, max(Y.array, na.rm = T)), ty="l")
plot(time, lambda.true[ 1, 2, ], ylim=c(0, max(Y.array, na.rm = T)), ty="l")
# plot( time, Y.array[ 1, 2, ] )
for(i in 1:p)for(j in 1:p){
if( i!=j ){
lines(time, lambda.true[ i, j, ], col=i+j)
# points( time, Y.array[ i, j, ], ylim=c(0, max(Y, na.rm = T)) )
}
}
lambda
X
lambda.true
dim(lambda.true)
dim(X)
